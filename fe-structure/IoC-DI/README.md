# IOC DI AOP概念解读
## 概念
> IOC: Inversion of Control，控制反转， 控制权从应用程序转移到框架（如IOC容器），是一种设计模式

此处关键字为“反转”，如果不反转，依赖关系是怎么样呢？如果A要使用B的方法，需要在A里面引入B
```javascript
// A.js
const B = require('B.js');
const b = new B({
    ...initParams
})

```
当然了，除了这种最基本的引入之外，还有很多设计模式可以实现依赖引入，大同小异，不反转时，只有A主动获取B之后，才能用到B。这时C也用到了B，C又引用了A，如果后面加需求，B需要使用A的方法，这种重复引用，反复引用的现象是很恶心的。

反转做了什么事呢？ A要调用B的话，A并不需要主动获取B，而是由其它人自动将B送上门来。这个“其它人”就是容器。描述了依赖关系，在使用时容器来做管理


> DI: Dependency Injection, 依赖注入，将相互依赖的对象分离，在配置中描述依赖关系，这些关系在应用时才被建立

如果IOC是一种设计模式，或者叫思想，那么DI是实现这种思想的一种方式。同时也可以通过观察者模式、模板方法模式等实现IOC，咱们拿DI举例。

awilix是一个DI框架，用它在应用中实现IOC。创建容器对依赖关系做管理


非IOC架构中，应用程序来决定引用哪些依赖，然后主动实例化；现在我们把这些工作交给IOC容器来完成，整个依赖对象的实例化、生命周期全部由容器接管,与业务代码高度解耦。


> AOP: 面向切面编程

AOP是一种编程范式，跟面向过程、面向对象、函数式等编程范式是同等概念。

是指在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想

举个栗子：

日志埋点、权限校验等侵入性比较强，又比较完整的模块，可能需要在不少地方调用该模块的方法，按面向对象思想，哪里用哪里引，这个方法遍地开花，不好维护，此时面向切面编程就很好解决了该问题。
```javascript
function log(logData) {
    console.log(logData);
}
function Auth(userType) {
    if(userType > 0) {
        alert('无权限')
    }

}

function getRoute(key) {
    return this.$route[key];
}

const newGetRoute = function(key) {
    Auth(user.type);
    getRoute(key);
    log('some log')
}

```
上面的案例简单描述了log和Auth对getRoute方法的侵入，事实上，Auth和log此时变成了该方法的两个pre和post的生命周期函数，在真正执行前后做了你想做的事情。redux里面到处都是


## 总结
总而言之：抛开业务类型和项目规模谈架构思想都是耍流氓，用各种骚操作完成todoList，除了学习需要就是无病呻吟。学习架构思想时又不能让业务喧宾夺主，只能用该思想完成较为简单的业务逻辑，咱们去体会，当你需要时你就知道了。
引用张小龙说微信新功能的表述：
> “你未看此花时，此花与汝同归于寂；你来看此花时，则此花颜色一时明白起来”；--王阳明

微信有很多强大的功能不去大势运营，不让他们打扰用户的的使用，当你需要用到时，发现他在

我们学架构、学思想也是这样，拥有这个能力后，不一定处处使用，当需要时，自然使出来，他就在那里。


---

>[从前端角度彻底搞懂 DIP、IoC、DI、JS](https://zhuanlan.zhihu.com/p/61018434)